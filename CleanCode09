using System.Data;
using System.Security.Cryptography;
using System.Text;

namespace Practice
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            VotingView votingView = new(new PresenterFactory());
        }
    }

    public interface IView
    {
        void ShowMessage(string message);
    }

    public class VotingView : IView
    {
        private readonly VotingPresenter _presenter;

        public VotingView(PresenterFactory factory)
        {
            ArgumentNullException.ThrowIfNull(factory);

            _presenter = factory.Create(this);
        }

        public void OnButtonClick()
        {
            string passport = Console.ReadLine();
            _presenter.TryFindPassport(passport);
        }

        public void ShowMessage(string message) => Console.WriteLine(message);
    }

    public class PresenterFactory
    {
        public VotingPresenter Create(IView view)
        {
            ArgumentNullException.ThrowIfNull(view);

            return new VotingPresenter(view);
        }
    }

    public class VotingPresenter
    {
        private const string Access = " доступ к бюллетеню на дистанционном электронном голосовании ПРЕДОСТАВЛЕН";
        private const string NotAccess = " доступ к бюллетеню на дистанционном электронном голосовании НЕ ПРЕДОСТАВЛЯЛСЯ";
        private const string NotFound = " в списке участников дистанционного голосования НЕ НАЙДЕН";

        private readonly IView _view;
        private readonly VotingService _service;

        public VotingPresenter(IView view)
        {
            _view = view ?? throw new ArgumentNullException(nameof(view));
            _service = new();
        }

        public void TryFindPassport(string rawPassport)
        {
            ArgumentException.ThrowIfNullOrEmpty(rawPassport);

            Passport passport = new (rawPassport);

            try
            {
                if (_service.FindAccess(passport.Series))
                    _view.ShowMessage(passport.Series + Access);
                else
                    _view.ShowMessage(passport.Series + NotAccess);
            }
            catch (ArgumentException)
            {
                _view.ShowMessage(passport.Series + NotFound);
            }
        }
    }

    public class VotingService
    {
        private IVotingRepository _pepository;
        private SHA1Hasher _hasher;

        public VotingService()
        {
            _pepository = new VotingRepository();
            _hasher = new SHA1Hasher();
        }

        public bool FindAccess(string passport)
        {
            string passportHash = _hasher.GetHash(passport);

            return _pepository.FindAccess(passportHash);
        }
    }

    public interface IVotingRepository
    {
        bool FindAccess(string passportHash);
    }

    public class VotingRepository : IVotingRepository
    {
        private const int Row = 0;
        private const int ItemArray = 1;

        private IDatabaseContext _context;

        public VotingRepository()
        {
            _context = new SQLiteContext();
        }

        public bool FindAccess(string passportHash)
        {
            ArgumentException.ThrowIfNullOrEmpty(passportHash);

            DataTable dataTable = _context.GetDataTable();

            bool access = Convert.ToBoolean(dataTable.Rows[Row].ItemArray[ItemArray]);

            Citizen citizen = CreateCitizen(access);

            return citizen.HasAccess;
        }

        public Citizen CreateCitizen(bool access) => new Citizen(access);
    }

    public interface IDatabaseContext
    {
        DataTable GetDataTable();
    }

    public class SQLiteContext : IDatabaseContext
    {


        public DataTable GetDataTable()
        {
            //SQLite work

            return new DataTable();
        }
    }

    public class Citizen
    {
        public Citizen(bool hasAccess)
        {
            HasAccess = hasAccess;
        }

        public bool HasAccess { get; }
    }

    public class Passport
    {
        private const string WrongFormat = "Неверный формат серии или номера паспорта";
        private const string Symbol = " ";
        private const int MinSymbols = 10;

        public Passport(string series)
        {
            ArgumentException.ThrowIfNullOrEmpty(series);

            series = series.Trim().Replace(Symbol, string.Empty);

            if (series.Length < MinSymbols)
                throw new ArgumentException(WrongFormat);

            Series = series;
        }

        public string Series { get; }
    }

    public class SHA1Hasher
    {
        public string GetHash(string input)
        {
            ArgumentException.ThrowIfNullOrEmpty(input);

            byte[] bytes = Encoding.UTF8.GetBytes(input);
            byte[] hashBytes = SHA1.HashData(bytes);

            return Convert.ToHexString(hashBytes);
        }
    }
}
