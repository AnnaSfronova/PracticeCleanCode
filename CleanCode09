using Microsoft.Data.Sqlite;
using System.Data;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;

namespace Practice
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            VotingView votingView = new(new PresenterFactory());
        }
    }

    public interface IView
    {
        void ShowMessage(string message);
    }

    public class VotingView : IView
    {
        private readonly VotingPresenter _presenter;

        public VotingView(PresenterFactory factory)
        {
            ArgumentNullException.ThrowIfNull(factory);

            _presenter = factory.Create(this);
        }

        public void OnButtonClick()
        {
            string passport = Console.ReadLine();
            _presenter.TryFindPassport(passport);
        }

        public void ShowMessage(string message) => Console.WriteLine(message);
    }

    public class PresenterFactory
    {
        public VotingPresenter Create(IView view)
        {
            ArgumentNullException.ThrowIfNull(view);

            return new VotingPresenter(view, new VotingService());
        }
    }

    public class VotingPresenter
    {
        private const string Access = " доступ к бюллетеню на дистанционном электронном голосовании ПРЕДОСТАВЛЕН";
        private const string NotAccess = " доступ к бюллетеню на дистанционном электронном голосовании НЕ ПРЕДОСТАВЛЯЛСЯ";

        private readonly IView _view;
        private readonly VotingService _service;

        public VotingPresenter(IView view, VotingService service)
        {
            _view = view ?? throw new ArgumentNullException(nameof(view));
            _service = service ?? throw new ArgumentNullException(nameof(service));
        }

        public void TryFindPassport(string rawPassport)
        {
            try
            {
                Passport passport = new(rawPassport);

                if (_service.FindAccess(passport))
                    _view.ShowMessage(passport.Series + Access);
                else
                    _view.ShowMessage(passport.Series + NotAccess);
            }
            catch (ArgumentException exception)
            {
                _view.ShowMessage(exception.Message);
            }
        }
    }

    public class VotingService
    {
        private IVotingRepository _pepository;
        private IHasher _hasher;

        public VotingService()
        {
            _pepository = new VotingRepository();
            _hasher = new SHA1Hasher();
        }

        public bool FindAccess(Passport passport)
        {
            ArgumentNullException.ThrowIfNull(passport);

            string passportHash = _hasher.GetHash(passport.Series);

            return _pepository.FindAccess(passportHash).HasAccess;
        }
    }

    public interface IVotingRepository
    {
        Citizen FindAccess(string passportHash);
    }

    public class VotingRepository : IVotingRepository
    {
        private const string NotFound = "В списке участников дистанционного голосования НЕ НАЙДЕН";
        private const int Row = 0;
        private const int ItemArray = 1;

        private IDatabaseContext _context;

        public VotingRepository()
        {
            _context = new SQLiteContext();
        }

        public Citizen FindAccess(string passportHash)
        {
            ArgumentException.ThrowIfNullOrEmpty(passportHash);

            DataTable dataTable = _context.GetDataTable();

            if (dataTable.Rows.Count < 0)
                throw new ArgumentException(NotFound);

            bool access = Convert.ToBoolean(dataTable.Rows[Row].ItemArray[ItemArray]);

            return new Citizen(access);
        }
    }

    public interface IDatabaseContext
    {
        DataTable GetDataTable();
    }

    public class SQLiteContext : IDatabaseContext
    {
        public DataTable GetDataTable()
        {
            return OpenDataTable();
        }

        private DataTable OpenDataTable()
        {
            string command = string.Format("select * from passports where num='{0}' limit 1;", (object)Form1.ComputeSha256Hash(rawData));
            string connection = string.Format("Data Source=" + Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) + "\\db.sqlite");

            try
            {
                SqliteConnection connection = new SqliteConnection(connection);
                connection.Open();

                SQLiteDataAdapter adapter = new SQLiteDataAdapter(new SQLiteCommand(command, connection));
                DataTable dataTable = new();
                adapter.Fill(dataTable);
                connection.Close();

                return dataTable;
            }
            catch (SQLiteException)
            {
                throw new InvalidOperationException("Файл db.sqlite не найден. Положите файл в папку вместе с exe.");
            }
        }
    }

    public class Citizen
    {
        public Citizen(bool hasAccess)
        {
            HasAccess = hasAccess;
        }

        public bool HasAccess { get; }
    }

    public class Passport
    {
        private const string WrongFormat = "Неверный формат серии или номера паспорта";
        private const string Symbol = " ";
        private const int MinSymbols = 10;

        public Passport(string series)
        {
            ArgumentException.ThrowIfNullOrEmpty(series);

            series = series.Trim().Replace(Symbol, string.Empty);

            if (series.Length < MinSymbols)
                throw new ArgumentException(WrongFormat);

            Series = series;
        }

        public string Series { get; }
    }

    public interface IHasher
    {
        public string GetHash(string input);
    }

    public class SHA1Hasher : IHasher
    {
        public string GetHash(string input)
        {
            ArgumentException.ThrowIfNullOrEmpty(input);

            byte[] bytes = Encoding.UTF8.GetBytes(input);
            byte[] hashBytes = SHA1.HashData(bytes);

            return Convert.ToHexString(hashBytes);
        }
    }
}
